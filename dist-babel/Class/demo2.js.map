{"version":3,"sources":["../../src/Class/demo2.es6"],"names":[],"mappings":";;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;IAiBM,O;AACF,uBAAc;AAAA;AAEb;;;;4BAEU;AACP,mBAAO,QAAP;AACH,S;0BAEQ,K,EAAO;AACZ,oBAAQ,GAAR,CAAY,YAAY,KAAxB;AACH;;;;;;AAEL,IAAI,OAAO,IAAI,OAAJ,EAAX;AACA,KAAK,IAAL,GAAY,GAAZ,C;AACA,QAAQ,GAAR,CAAY,KAAK,IAAjB,E;;;;;;;;IAOM,G;;;;;;;sCACkB;AAChB,mBAAO,OAAP;AACH;;;;;;AAEL,QAAQ,GAAR,CAAY,IAAI,WAAJ,EAAZ,E;AACA,IAAI,MAAM,IAAI,GAAJ,EAAV;;;IAGM,Q;;;;;;;;;;EAAiB,G;;AAGvB,QAAQ,GAAR,CAAY,SAAS,WAAT,EAAZ,E;;;;;;;;;;;;;;;IAcM,Q;;;;AACN,SAAS,IAAT,GAAgB,CAAhB,C;AACA,QAAQ,GAAR,CAAY,SAAS,IAArB,E;;;;;;;;;;;;;;;;;;IAiBM,G;AACF,mBAAoB;AAAA;;AAAA,0CAAL,IAAK;AAAL,gBAAK;AAAA;;AAChB,aAAK,IAAL,GAAY,IAAZ;AACH;;;aACE,OAAO,Q;;gGACE,G;;;;;;;;;;wCAAO,KAAK,I;;;;;;;;AAAZ,+B;;mCACE,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIlB,0BAAa,IAAI,GAAJ,CAAQ,OAAR,EAAgB,OAAhB,CAAb,mIAAsC;AAAA,YAA9B,CAA8B;;AAClC,gBAAQ,GAAR,CAAY,CAAZ;AACH;;;;;;;;;;;;;;;;;;;;;;;;;AAUD,SAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,QAAI,IAAI,MAAJ,KAAe,MAAnB,EAA2B;AACvB,aAAK,IAAL,GAAY,IAAZ;AACH,KAFD,MAEO;AACH,cAAM,IAAI,KAAJ,CAAU,aAAV,CAAN;AACH;AACJ;;AAED,IAAI,SAAS,IAAI,MAAJ,CAAW,IAAX,CAAb,C;;;IAGM,M,GACF,kBAAa;AAAA;;AACT,YAAQ,GAAR,CAAY,IAAI,MAAJ,KAAe,MAA3B;AACH,C;;IAEC,K;;;AACF,qBAAa;AAAA;;AAAA;AAEZ;;;EAHe,M;;AAKpB,IAAI,MAAJ,G;AACA,IAAI,KAAJ,G;;;;IAGM,K,GACF,iBAAc;AAAA;;AACV,QAAI,IAAI,MAAJ,KAAe,KAAnB,EAA0B;AACtB,cAAM,IAAI,KAAJ,CAAU,SAAV,CAAN;AACH;AACJ,C;;IAGC,S;;;AACF,uBAAY,MAAZ,EAAoB,KAApB,EAA2B;AAAA;;AAAA;;AAG1B;;;EAJmB,K;;;;;AAQxB,IAAI,IAAI,IAAI,SAAJ,CAAc,CAAd,EAAiB,CAAjB,CAAR,C","file":"demo2.js","sourcesContent":["/**\r\n *   Created by sammy on 2016/7/13\r\n */\r\n'use strict';\r\n\r\n/**\r\n * Extends 的继承目标\r\n * class B extends A{ }  A只要是一个有prototype属性的函数，就能被B继承，A可以是任意函数。\r\n * */\r\n\r\n/**\r\n * super 关键字\r\n * 1、作为函数调用时，super代表父类的构造函数。\r\n * 2、作为对象调用时，super代表父类，可以引用父类的属性和方法，也可以引用父类的静态方法。\r\n * */\r\n\r\n\r\n/**\r\n * Class的取值函数（getter）和存值函数（setter）\r\n * */\r\nclass MyClass {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    get prop() {\r\n        return 'getter';\r\n    }\r\n\r\n    set prop(value) {\r\n        console.log('setter:' + value);\r\n    }\r\n}\r\nlet inst = new MyClass();\r\ninst.prop = 123;    // setter:123\r\nconsole.log(inst.prop); // getter\r\n\r\n/**\r\n * Class的静态方法：类中定义的方法前面加个 static 关键字。\r\n * 类中定义的方法都会被实例继承，如果在一个方法前面加上 static 关键字，该方法就不会被实例继承。\r\n * 总之：1、实例继承类的非静态方法。2、子类可以继承父类的静态方法。3、静态方法也可以从 super 对象上调用。\r\n * */\r\nclass Bar{\r\n    static classMethod(){\r\n        return 'hello';\r\n    }\r\n}\r\nconsole.log(Bar.classMethod()); // hello\r\nvar bar = new Bar();\r\n//console.log(bar.classMethod()); //  bar.classMethod is not a function\r\n\r\nclass BarChild extends Bar{\r\n\r\n}\r\nconsole.log(BarChild.classMethod());  // hello\r\n\r\n/**\r\n * Class的静态属性和实例属性。（注：Class内部只有静态方法，没有静态属性，Class的构造函数中定义的是【实例属性】）\r\n * 静态属性：指Class本身的属性，而不是定义在实例对象（this）上的属性。\r\n * ES7提案中可以用等式在类的内部定义类的【实例属性】。比如：\r\n * class MyClass{\r\n *      myProp = 42;\r\n *\r\n *      constructor(){\r\n *          console.log(this.myProp);   // 42\r\n *      }\r\n * }\r\n * */\r\nclass MyClass2{}\r\nMyClass2.prop = 2;  // ES6 中定义类的静态属性\r\nconsole.log(MyClass2.prop); // 2\r\n\r\n// ES7 中定义类的静态属性，在node v6下报错\r\n//class MyClass3{\r\n//    static prop = 42;\r\n//    constructor(){\r\n//        console.log(MyClass3.prop); // 42\r\n//    }\r\n//}\r\n//new MyClass3();\r\n\r\n/**\r\n * Class的 Generator 方法\r\n * */\r\n\r\n// Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。\r\n// Symbol.iterator方法返回一个Foo类的默认遍历器，【for...of循环会自动调用这个遍历器】。\r\nclass Foo{\r\n    constructor(...args){\r\n        this.args = args;\r\n    }\r\n    * [Symbol.iterator](){\r\n        for(let arg of this.args){\r\n            yield arg;\r\n        }\r\n    }\r\n}\r\nfor(let x of new Foo('hello','world')){\r\n    console.log(x);\r\n}\r\n// hello\r\n// world\r\n\r\n/**\r\n * new.target 属性：返回new命令作用于的那个构造函数。Class内部调用 new.target 会返回当前Class。\r\n * 可以用来确定构造函数是怎么调用的。\r\n * 注意：子类继承父类时，new.target 返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。\r\n * */\r\n// 另一种写法\r\nfunction Person(name) {\r\n    if (new.target === Person) {\r\n        this.name = name;\r\n    } else {\r\n        throw new Error('必须使用new生成实例');\r\n    }\r\n}\r\n\r\nvar person = new Person('张三'); // 正确\r\n//var notAPerson = Person.call(person, '张三');  // 报错\r\n\r\nclass Father{\r\n    constructor(){\r\n        console.log(new.target === Father);\r\n    }\r\n}\r\nclass Child extends Father{\r\n    constructor(){\r\n        super();\r\n    }\r\n}\r\nnew Father();   // true\r\nnew Child();    // false\r\n\r\n// 让某个类无法单独使用，只能被继承\r\nclass Shape {\r\n    constructor() {\r\n        if (new.target === Shape) {\r\n            throw new Error('本类不能实例化');\r\n        }\r\n    }\r\n}\r\n\r\nclass Rectangle extends Shape {\r\n    constructor(length, width) {\r\n        super();\r\n        // ...\r\n    }\r\n}\r\n\r\n//var x = new Shape();  // 报错\r\nvar y = new Rectangle(3, 4);  // 正确\r\n\r\n\r\n"]}